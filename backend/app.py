import json

from flask import Flask
from flask_restx import Api, Resource, fields
from flask_cors import CORS

from server.bo.Student import Student
from server.db.NotFoundException import NotFoundException
from server.db.StudentMapper import StudentMapper

# TODO: Außerdem nutzen wir einen selbstgeschriebenen Decorator, der die Authentifikation übernimmt
# from SecurityDecorator import secured

app = Flask(__name__)

"""
Allow **Cross-Origin Resource Sharing** (CORS) -> React needs to access our sources
"""
CORS(app, resources=r'*')

api = Api(app, version='1.0', title='LernApp API')

"""
We got a "Api-Namespace" that is used to group all
Student-Related Operations.
"""
students = api.namespace('students', description='Access Student infos')

"""
The marshaller is used to "format" our Student.
We use the formatted Response to answer the Request.
React can than use this data top display the page.
"""
studentMarshaller = api.model('Student', {
    # TODO: pass all required fields to React
    'id': fields.Integer(attribute='_id'),
    'first_name': fields.String(attribute='_first_name', description='First name'),
    'last_name': fields.String(attribute='_last_name', description='Last name')
})


@students.route('/<int:receiving_student_id>/request_conversation')
@students.param('receiving_student_id', 'ID of the receiving student')
class ConversationRequest(Resource):
    # @secured
    @students.doc(description='Send conversation request from one user to an other')
    @students.response(204,
                       '204 is "No content" I need no response, just a success message that the request was submitted')
    def post(self, receiving_student_id):
        # TODO: send a conversation request to the "receiving_student_id"
        return 204


@students.route('/<string:email>')
@students.param('email', 'email of student')
class StudentByEmail(Resource):
    @students.marshal_with(studentMarshaller)
    @students.response(404, 'When the student was not found')
    # @secured
    def get(self, email: str):
        with StudentMapper() as mapper:
            return mapper.find_by_email(email)


@students.route('/')
class Students(Resource):
    # @secured
    @students.doc(description='List of all students')
    @students.marshal_with(studentMarshaller)
    def get(self):
        with StudentMapper() as mapper:
            return mapper.find_all()

    @students.marshal_with(studentMarshaller)
    @students.expect(
        api.model('Student Creation', {
            'email': fields.String(attribute='_email'),
            'first_name': fields.String(attribute='_first_name', description='First name'),
            'last_name': fields.String(attribute='_last_name', description='Last name')
        })
    )
    def post(self):
        """
        api.payload it magic from flaskx and contains the data
        we defined in @students.expect before.
        """
        creation = api.payload

        """
        We can receive the data from studentCreation to
        populate a new user.

        The id will be generated by MySQL later
        """
        with StudentMapper() as mapper:
            return mapper.insert(Student(
                creation["email"],
                creation["first_name"],
                creation["last_name"],
                creation["email"],  # TODO: check
                creation["email"],  # TODO: check
                5  # TODO: check
            ))


@students.route('/<int:id>')
@students.param('id', 'ID of the student')
class StudentOperations(Resource):
    @students.marshal_with(studentMarshaller)
    @students.response(404, 'When the student was not found')
    # @secured
    def get(self, id):
        with StudentMapper() as mapper:
            return mapper.find_by_id(id)

    @students.marshal_with(studentMarshaller)
    # @secured
    def post(self, id):
        # TODO: receive data from the request and update the person
        #       See: class Students.update()
        with StudentMapper() as mapper:
            return mapper.find_by_id(id)

    @students.response(204,
                       '204 is "No content" and means the Student is gone now')
    def delete(self, id):
        with StudentMapper() as mapper:
            mapper.delete(id)
            return 204


"""
We have a global error handler that reacts to all NotFoundExceptions
and responds with a 404 Not Found HTTP-StatusCode.
React can analyze the status code and present a proper NotFound page
to the user.
"""


@app.errorhandler(NotFoundException)
def handle_exception(exception):
    return exception.message, 404


if __name__ == '__main__':
    app.run(debug=True)

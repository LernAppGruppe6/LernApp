import json

from flask import Flask
from flask_restx import Api, Resource, fields
from flask_cors import CORS

from server.db.GroupMapper import GroupMapper
from server.bo.Group import Group
from server.bo.Student import Student
from server.db.NotFoundException import NotFoundException
from server.db.StudentMapper import StudentMapper

# TODO: Außerdem nutzen wir einen selbstgeschriebenen Decorator, der die Authentifikation übernimmt
# from SecurityDecorator import secured

app = Flask(__name__)

"""
Allow **Cross-Origin Resource Sharing** (CORS) -> React needs to access our sources
"""
CORS(app, resources=r'*')

api = Api(app, version='1.0', title='LernApp API')

"""
 ---------------- Student related methods ---------------------------------
"""

"""
We got a "Api-Namespace" that is used to group all
Student-Related Operations.
"""
students = api.namespace('students', description='Access Student infos')

"""
The marshaller is used to "format" our Student.
We use the formatted Response to answer the Request.
React can than use this data top display the page.
"""
studentMarshaller = api.model('Student', {
    # TODO: pass all required fields to React
    'id': fields.Integer(attribute='_id'),
    'first_name': fields.String(attribute='_first_name', description='First name'),
    'last_name': fields.String(attribute='_last_name', description='Last name'),
    'age': fields.String(attribute='_age', description="Age"),
    'gender': fields.String(attribute='_gender', description="Gender"),
    'university': fields.String(attribute='_university', description="University"),
    'degree_program': fields.String(attribute='_degree_program', description="Degree Program"),
    'content_interests': fields.String(attribute='_content_interests', description="Content Interests"),
    'self_assesment': fields.String(attribute='_self_assesment', description="Self Assesment"),
    'semester': fields.String(attribute='_semester', description="Semester"),
})


@students.route('/<int:receiving_student_id>/request_conversation')
@students.param('receiving_student_id', 'ID of the receiving student')
class ConversationRequest(Resource):
    # @secured
    @students.doc(description='Send conversation request from one user to an other')
    @students.response(204,
                       '204 is "No content" I need no response, just a success message that the request was submitted')
    def post(self, receiving_student_id):
        # TODO: send a conversation request to the "receiving_student_id"
        return 204


@students.route('/<string:email>')
@students.param('email', 'email of student')
class StudentByEmail(Resource):
    @students.marshal_with(studentMarshaller)
    @students.response(404, 'When the student was not found')
    # @secured
    # TODO: add security decorator
    def get(self, email: str):
        with StudentMapper() as mapper:
            return mapper.find_by_email(email)


@students.route('/')
class Students(Resource):
    # @secured
    # TODO: add security decorator
    @students.doc(description='List of all students')
    @students.marshal_with(studentMarshaller)
    def get(self):
        with StudentMapper() as mapper:
            return mapper.find_all()

    @students.marshal_with(studentMarshaller)
    @students.expect(
        api.model('Student Creation', {
            'email': fields.String(attribute='_email'),
            'first_name': fields.String(attribute='_first_name', description='First name'),
            'last_name': fields.String(attribute='_last_name', description='Last name'),
            'age': fields.Integer(attribute='_age', description='Age'),
        })
    )
    def post(self):
        """
        api.payload it magic from flaskx and contains the data
        we defined in @students.expect before.
        """
        creation = api.payload

        """
        We can receive the data from studentCreation to
        populate a new user.

        The id will be generated by MySQL later
        """
        with StudentMapper() as mapper:
            return mapper.insert(Student(
                creation["email"],
                creation["first_name"],
                creation["last_name"],
                creation["email"],  # TODO: check
                creation["email"],  # TODO: check
                5,  # TODO: check
                creation["age"],
                creation["gender"]
            ))


@students.route('/<int:id>')
@students.param('id', 'ID of the student')
class StudentOperations(Resource):
    @students.marshal_with(studentMarshaller)
    @students.response(404, 'When the student was not found')
    # @secured
    def get(self, id):
        with StudentMapper() as mapper:
            return mapper.find_by_id(id)

    @students.marshal_with(studentMarshaller)
    # @secured
    def post(self, id):
        # TODO: receive data from the request and update the person
        #       See: class Students.update()
        with StudentMapper() as mapper:
            return mapper.find_by_id(id)

    @students.response(204,
                       '204 is "No content" and means the Student is gone now')
    def delete(self, id):
        with StudentMapper() as mapper:
            mapper.delete(id)
            return 204

"""
We have a global error handler that reacts to all NotFoundExceptions
and responds with a 404 Not Found HTTP-StatusCode.
React can analyze the status code and present a proper NotFound page
to the user.
"""


@app.errorhandler(NotFoundException)
def handle_exception(exception):
    return exception.message, 404


if __name__ == '__main__':
    app.run(debug=True)

"""
 ---------------- Group related methods ---------------------------------
"""
# TODO: add needed methods in groupmapper.py
# TODO: delete useless methods in groupmapper.py
# TODO: fix class Group.py

"""
We got a "Api-Namespace" that is used to group all
Group-Related Operations.
"""
groups = api.namespace('groups', description='Access Student infos')

"""
The marshaller is used to "format" our Group.
We use the formatted Response to answer the Request.
React can than use this data top display the page.
"""
groupMarshaller = api.model('Group', {
    # TODO: pass all required fields to React
    'id': fields.Integer(attribute='_id'),
    'name': fields.String(attribute='_name', description='Name'),
})


@groups.route('/')
class Groups(Resource):
    # @secured
    # TODO: add security decorator
    @groups.doc(description='List of all groups')
    @groups.marshal_with(groupMarshaller)
    def get(self):
        with GroupMapper() as mapper:
            return mapper.find_all()
    @groups.marshal_with(groupMarshaller)
    @groups.expect(
        api.model('Group Creation', {
            'name': fields.String(attribute='_name', description='Name'),
        })
    )
    def post(self):
        """
        api.payload it magic from flaskx and contains the data
        we defined in @groups.expect before.
        """
        creation = api.payload

        """
        We can receive the data from groupCreation to
        populate a new goup.

        The id will be generated by MySQL later
        """
        with GroupMapper() as mapper:
            return mapper.insert(Group(
                creation["name"],
            ))

@groups.route('/<int:id>')
@groups.param('id', 'ID of the group')
class GroupOperations(Resource):
    @groups.marshal_with(groupMarshaller)
    @groups.response(404, 'When the group was not found')
    # @secured
    # TODO: add security decorator
    def get(self, id):
        with GroupMapper() as mapper:
            return mapper.find_by_id(id)

    @groups.marshal_with(groupMarshaller)
    # @secured
    # TODO: add security decorator
    def post(self, id):
        # TODO: receive data from the request and update the group
        #       See: class Groups.update()
        with GroupMapper() as mapper:
            return mapper.find_by_id(id)

    @groups.response(204,
                       '204 is "No content" and means the Group is gone now')
    def delete(self, id):
        with GroupMapper() as mapper:
            mapper.delete(id)
            return 204

"""
We have a global error handler that reacts to all NotFoundExceptions
and responds with a 404 Not Found HTTP-StatusCode.
React can analyze the status code and present a proper NotFound page
to the user.
"""


@app.errorhandler(NotFoundException)
def handle_exception(exception):
    return exception.message, 404


if __name__ == '__main__':
    app.run(debug=True)

